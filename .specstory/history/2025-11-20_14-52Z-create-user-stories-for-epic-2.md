<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 6da05104-0134-4875-a312-77f3b7de43cc (2025-11-20 14:52Z) -->

# Create user stories for epic 2 (2025-11-20 14:52Z)

_**User (2025-11-20 13:18Z)**_

@sm.mdc 



create stories for epic 2

---

_**Agent (model composer-1, mode Agent)**_



---


Activating the SM agent and reviewing Epic 2 to draft stories.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .cursor/rules/bmad/bmm/agents/sm.mdc</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/epics.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/sprint-planning.md</summary>

</details>
</tool-use>

---



---


Reading the SM agent file to understand the persona and instructions:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/agents/sm.md</summary>

</details>
</tool-use>

---



---


Loading the config file, then creating stories for Epic 2.


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/config.yaml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/workflows/4-implementation/create-story/workflow.yaml</summary>

</details>
</tool-use>

---



---


Reading the workflow execution instructions and create-story instructions:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/core/tasks/workflow.xml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/workflows/4-implementation/create-story/instructions.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---



---


Checking sprint status to identify Epic 2 stories to create:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/sprint-status.yaml</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/workflows/4-implementation/create-story/template.md</summary>

</details>
</tool-use>

---



---


Creating Epic 2 stories. Checking if Epic 2 is tracked in sprint-status.yaml, then creating the story files.


---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "epic-2|2-1-|2-2-|2-3-|2-4-|2-5-|2-6-|2-7-" in "docs/sprint-status.yaml" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/architecture.md</summary>

</details>
</tool-use>

---



---


Epic 2 stories aren't in sprint-status.yaml. Adding them, then creating the story files. Updating sprint-status.yaml first:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/sprint-status.yaml</summary>

</details>
</tool-use>

---



---


Adding Epic 2 stories to sprint-status.yaml, then creating story files for each:


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-status.yaml</summary>

**Chunk 1**
Lines added: 9, lines removed: undefined

```diff
@@ -32,4 +32,13 @@
    1-1-project-structure: drafted
    epic-1-retrospective: optional
+   epic-2: backlog
+   2-1-websocket-server-setup-with-nestjs-gateway: backlog
+   2-2-game-code-generation: backlog
+   2-3-game-creation-with-initial-state: backlog
+   2-4-game-joining-with-validation: backlog
+   2-5-websocket-message-protocol-implementation: backlog
+   2-6-message-validation-and-error-handling: backlog
+   2-7-connection-management-and-cleanup: backlog
+   epic-2-retrospective: optional
  
  
```

</details>

</tool-use>

---



---


Creating Epic 2 story files. Loading required context, then creating each story:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/epics.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/prd.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: .bmad/bmm/workflows/4-implementation/create-story/checklist.md</summary>

</details>
</tool-use>

---



---


Creating Epic 2 story files, starting with Story 2.1:


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/sprint-artifacts/1-4-server-package-setup-with-nestjs.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: docs/architecture.md</summary>

</details>
</tool-use>

---



---


Creating all 7 Epic 2 story files. Starting with Story 2.1:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md</summary>

**Chunk 1**
Lines added: 125, lines removed: 1

```diff
@@ -1,1 +1,125 @@
- 
+ # Story 2.1: WebSocket Server Setup with NestJS Gateway
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a developer,
+ I want a WebSocket server using NestJS Gateway,
+ So that clients can establish persistent connections for real-time communication.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** the server package is set up (Story 1.4)
+    **When** I create the WebSocket Gateway
+    **Then** &#96;packages/server/src/presentation/game/game.gateway.ts&#96; exists with:
+    - &#96;@WebSocketGateway()&#96; decorator configured for port 3001 (or from environment)
+    - &#96;handleConnection()&#96; method that logs new connections
+    - &#96;handleDisconnect()&#96; method that logs disconnections
+    - Basic WebSocket message handling structure
+ 
+ 2. **And** &#96;packages/server/src/presentation/game/game.module.ts&#96; exists and:
+    - Imports &#96;WebSocketsModule&#96; from &#96;@nestjs/websockets&#96;
+    - Provides &#96;GameGateway&#96; as a provider
+    - Can be imported by &#96;AppModule&#96;
+ 
+ 3. **And** server starts successfully and accepts WebSocket connections on configured port
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Create WebSocket Gateway class (AC: #1)
+   - [ ] Create &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Import &#96;WebSocketGateway&#96;, &#96;WebSocketServer&#96;, &#96;OnGatewayConnection&#96;, &#96;OnGatewayDisconnect&#96; from &#96;@nestjs/websockets&#96;
+   - [ ] Import &#96;Server&#96; from &#96;socket.io&#96; (or &#96;ws&#96; based on NestJS adapter)
+   - [ ] Create &#96;GameGateway&#96; class implementing &#96;OnGatewayConnection&#96;, &#96;OnGatewayDisconnect&#96;
+   - [ ] Add &#96;@WebSocketGateway()&#96; decorator with port configuration from environment variable (default 3001)
+   - [ ] Implement &#96;handleConnection(client: Socket)&#96; method that logs connection with client ID
+   - [ ] Implement &#96;handleDisconnect(client: Socket)&#96; method that logs disconnection with client ID
+   - [ ] Add basic message handler structure (placeholder for future message handling)
+   - [ ] Test: Verify gateway class compiles without errors
+   - [ ] Test: Verify gateway can be instantiated
+ 
+ - [ ] Task 2: Create Game Module (AC: #2)
+   - [ ] Create &#96;packages/server/src/presentation/game/game.module.ts&#96;
+   - [ ] Import &#96;Module&#96; from &#96;@nestjs/common&#96;
+   - [ ] Import &#96;WebSocketsModule&#96; from &#96;@nestjs/websockets&#96;
+   - [ ] Import &#96;GameGateway&#96; from &#96;./game.gateway&#96;
+   - [ ] Create &#96;GameModule&#96; class with &#96;@Module()&#96; decorator
+   - [ ] Add &#96;imports: [WebSocketsModule]&#96; to module metadata
+   - [ ] Add &#96;providers: [GameGateway]&#96; to module metadata
+   - [ ] Test: Verify module compiles without errors
+   - [ ] Test: Verify module can be imported by AppModule
+ 
+ - [ ] Task 3: Integrate Gateway with AppModule (AC: #2, #3)
+   - [ ] Open &#96;packages/server/src/presentation/app.module.ts&#96; (or create if needed)
+   - [ ] Import &#96;GameModule&#96; from &#96;./game/game.module&#96;
+   - [ ] Add &#96;GameModule&#96; to &#96;imports&#96; array in &#96;AppModule&#96;
+   - [ ] Update &#96;main.ts&#96; to ensure WebSocket adapter is configured
+   - [ ] Test: Run &#96;npm run dev&#96; and verify server starts successfully
+   - [ ] Test: Verify server accepts WebSocket connections on configured port
+   - [ ] Test: Verify connection/disconnection events are logged
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 1.4 (Status: drafted)**
+ 
+ - **Server Package Setup**: NestJS server package configured with TypeScript, dependencies installed, directory structure created [Source: docs/sprint-artifacts/1-4-server-package-setup-with-nestjs.md]
+ - **Directory Structure**: Layered architecture structure exists: &#96;domain/&#96;, &#96;application/&#96;, &#96;infrastructure/&#96;, &#96;presentation/&#96; [Source: docs/sprint-artifacts/1-4-server-package-setup-with-nestjs.md]
+ - **NestJS Configuration**: NestJS application bootstrap exists in &#96;main.ts&#96; [Source: docs/sprint-artifacts/1-4-server-package-setup-with-nestjs.md]
+ - **Use Existing Structure**: Gateway should be created in &#96;presentation/game/&#96; directory following established patterns
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **NestJS Gateway Pattern**: Architecture mandates NestJS Gateway pattern for WebSocket handling [Source: docs/architecture.md#Technology-Stack-Details]
+ - **WebSocket Support**: NestJS provides WebSocket Gateway via &#96;@nestjs/websockets&#96; with Gateway pattern [Source: docs/architecture.md#Technology-Stack-Details]
+ - **Port Configuration**: Server ports configured via environment variables (3001 for Server A, 3002 for Server B) [Source: docs/architecture.md#Integration-Points]
+ - **Layered Architecture**: Gateway belongs in presentation layer, depends on application services [Source: docs/architecture.md#Project-Structure]
+ - **Connection Lifecycle**: Gateway handles connection lifecycle automatically via &#96;OnGatewayConnection&#96; and &#96;OnGatewayDisconnect&#96; interfaces [Source: docs/architecture.md#Technology-Stack-Details]
+ 
+ ### Project Structure Notes
+ 
+ - Gateway file location: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Module file location: &#96;packages/server/src/presentation/game/game.module.ts&#96;
+ - Gateway follows NestJS decorator pattern with &#96;@WebSocketGateway()&#96;
+ - Connection tracking will be needed for game session management (future stories)
+ - Port configuration from environment enables multiple server instances
+ 
+ ### Testing Standards
+ 
+ - Use NestJS testing utilities: &#96;Test.createTestingModule()&#96; for integration tests [Source: docs/architecture.md#Technology-Stack-Details]
+ - Mock WebSocket connections using test clients
+ - Test connection/disconnection handlers
+ - Gateway tests should verify decorator configuration and lifecycle methods
+ - TDD approach: Write tests first, then implement gateway
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.1-WebSocket-Server-Setup-with-NestJS-Gateway]
+ - [Source: docs/architecture.md#Technology-Stack-Details]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/architecture.md#NestJS-Patterns-Used]
+ - [Source: docs/prd.md#WebSocket-Message-Protocol]
+ - [Source: docs/sprint-planning.md#Development-Principles]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---



---


Creating the remaining Epic 2 stories:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-2-game-code-generation.md</summary>

**Chunk 1**
Lines added: 115, lines removed: 1

```diff
@@ -1,1 +1,115 @@
- 
+ # Story 2.2: Game Code Generation
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a developer,
+ I want a system to generate unique game codes,
+ So that players can share codes to join the same game.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** a game creation request
+    **When** I generate a game code
+    **Then** the code is:
+    - 6 alphanumeric characters (e.g., &quot;ABC123&quot;, &quot;XYZ789&quot;)
+    - Unique (not already in use)
+    - Case-sensitive
+    - Generated using cryptographically secure random (or simple random for MVP)
+ 
+ 2. **And** game code generation is implemented in:
+    - Domain value object: &#96;GameCode&#96; (if using DDD) or utility function
+    - Application service: &#96;GameService.createGame()&#96; generates code before creating game
+ 
+ 3. **And** generated codes are stored with game state for validation
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Create GameCode value object or utility (AC: #1, #2)
+   - [ ] Create &#96;packages/server/src/domain/value-objects/GameCode.ts&#96; (or utility function)
+   - [ ] Implement code generation function: &#96;generateGameCode(): string&#96;
+   - [ ] Use crypto.randomBytes or Math.random for MVP (6 characters)
+   - [ ] Generate alphanumeric characters (A-Z, a-z, 0-9)
+   - [ ] Ensure code is exactly 6 characters
+   - [ ] Test: Verify generated codes are 6 characters long
+   - [ ] Test: Verify codes contain only alphanumeric characters
+   - [ ] Test: Verify codes are case-sensitive (test uppercase/lowercase)
+ 
+ - [ ] Task 2: Implement uniqueness check (AC: #1)
+   - [ ] Create interface &#96;IGameRepository&#96; with &#96;exists(gameCode: string): Promise&lt;boolean&gt;&#96; method
+   - [ ] Implement uniqueness check: query Redis (or storage) to verify code doesn&#39;t exist
+   - [ ] Add retry logic: if code exists, generate new code (max 10 retries)
+   - [ ] Test: Mock repository to test uniqueness validation
+   - [ ] Test: Verify retry logic works when duplicate code generated
+ 
+ - [ ] Task 3: Integrate code generation with game creation (AC: #2, #3)
+   - [ ] Create &#96;GameService&#96; class in &#96;packages/server/src/application/services/GameService.ts&#96;
+   - [ ] Add &#96;createGame()&#96; method that generates code before creating game
+   - [ ] Call &#96;generateGameCode()&#96; and verify uniqueness
+   - [ ] Store generated code with game state
+   - [ ] Test: Verify code generation happens before game creation
+   - [ ] Test: Verify generated code is stored with game state
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 2.1 (Status: drafted)**
+ 
+ - **WebSocket Gateway**: GameGateway exists in &#96;presentation/game/game.gateway.ts&#96; [Source: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md]
+ - **Game Module**: GameModule configured with WebSocketsModule [Source: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md]
+ - **Connection Handling**: Connection/disconnection handlers implemented [Source: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md]
+ - **Use Gateway**: Code generation will be used by GameGateway when handling game creation messages
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Domain Value Objects**: Architecture specifies domain/value-objects directory for value objects [Source: docs/architecture.md#Project-Structure]
+ - **Pure Domain Logic**: Domain layer should have no external dependencies (pure TypeScript) [Source: docs/architecture.md#Code-Organization]
+ - **Game Code Format**: 6 alphanumeric characters provides good balance of uniqueness and usability [Source: docs/epics.md#Story-2.2-Game-Code-Generation]
+ - **Uniqueness Validation**: Codes stored in Redis with game state for validation [Source: docs/epics.md#Story-2.2-Game-Code-Generation]
+ - **Random Generation**: Simple random generation acceptable for MVP (crypto.randomBytes for production) [Source: docs/epics.md#Story-2.2-Game-Code-Generation]
+ 
+ ### Project Structure Notes
+ 
+ - Value object location: &#96;packages/server/src/domain/value-objects/GameCode.ts&#96;
+ - Service location: &#96;packages/server/src/application/services/GameService.ts&#96;
+ - Repository interface: &#96;packages/server/src/domain/interfaces/IGameRepository.ts&#96;
+ - GameCode should be a pure domain value object (no infrastructure dependencies)
+ - Uniqueness check requires repository interface (will be implemented in infrastructure layer)
+ 
+ ### Testing Standards
+ 
+ - Domain value objects: Pure unit tests with no mocks (100% coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Test code generation logic thoroughly
+ - Test uniqueness validation with mocked repository
+ - Test retry logic for duplicate codes
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.2-Game-Code-Generation]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/architecture.md#Code-Organization]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md</summary>

**Chunk 1**
Lines added: 149, lines removed: 1

```diff
@@ -1,1 +1,149 @@
- 
+ # Story 2.3: Game Creation with Initial State
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a player,
+ I want to create a new game and receive a game code,
+ So that I can share it with an opponent to start playing.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** a client sends &#96;{ type: &#39;join&#39;, gameCode: &#39;NEW&#39; }&#96; message
+    **When** the server processes the game creation request
+    **Then** the server:
+    - Generates a unique game code (Story 2.2)
+    - Creates game state with:
+      - Empty 3x3 board (all cells empty: &#96;[[&quot;&quot;, &quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;, &quot;&quot;]]&#96;)
+      - Status: &#96;&#39;waiting&#39;&#96;
+      - Current player: &#96;&#39;X&#39;&#96;
+      - No winner: &#96;null&#96;
+      - Empty players object: &#96;{ X: undefined, O: undefined }&#96;
+    - Stores game state in Redis with key &#96;game:{gameCode}&#96;
+    - Assigns player &#39;X&#39; to the creating client
+    - Sends &#96;joined&#96; message to client with:
+      - &#96;type: &#39;joined&#39;&#96;
+      - &#96;gameCode: string&#96; (generated code)
+      - &#96;board: BoardDTO&#96; (empty 3x3 grid)
+      - &#96;currentPlayer: &#39;X&#39;&#96;
+      - &#96;status: &#39;waiting&#39;&#96;
+      - &#96;playerSymbol: &#39;X&#39;&#96;
+ 
+ 2. **And** game state includes TTL (e.g., 3600 seconds = 1 hour) for automatic cleanup
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Create Game entity/domain model (AC: #1)
+   - [ ] Create &#96;packages/server/src/domain/entities/Game.ts&#96;
+   - [ ] Define Game class with properties: &#96;gameCode&#96;, &#96;board&#96;, &#96;status&#96;, &#96;currentPlayer&#96;, &#96;winner&#96;, &#96;players&#96;, &#96;createdAt&#96;, &#96;updatedAt&#96;
+   - [ ] Add constructor that initializes empty 3x3 board
+   - [ ] Add method to convert to DTO: &#96;toDTO(): GameDTO&#96;
+   - [ ] Test: Verify Game entity creates with correct initial state
+   - [ ] Test: Verify empty board is 3x3 with all empty cells
+ 
+ - [ ] Task 2: Implement CreateGameUseCase (AC: #1)
+   - [ ] Create &#96;packages/server/src/application/use-cases/CreateGameUseCase.ts&#96;
+   - [ ] Inject &#96;IGameRepository&#96; and &#96;GameCodeGenerator&#96; (or utility)
+   - [ ] Implement &#96;execute(connectionId: string): Promise&lt;GameDTO&gt;&#96;
+   - [ ] Generate unique game code using GameCodeGenerator
+   - [ ] Create Game entity with initial state (empty board, status &#39;waiting&#39;, currentPlayer &#39;X&#39;)
+   - [ ] Assign player &#39;X&#39; to connectionId in players object
+   - [ ] Save game to repository with TTL (3600 seconds)
+   - [ ] Return GameDTO with game code and initial state
+   - [ ] Test: Mock repository and verify game creation flow
+   - [ ] Test: Verify game code generation and uniqueness check
+   - [ ] Test: Verify initial state is correct (empty board, waiting status)
+ 
+ - [ ] Task 3: Implement Redis game repository (AC: #1)
+   - [ ] Create &#96;packages/server/src/infrastructure/redis/redis-game.repository.ts&#96;
+   - [ ] Implement &#96;IGameRepository&#96; interface
+   - [ ] Implement &#96;create(game: Game, ttl: number): Promise&lt;Game&gt;&#96;
+   - [ ] Store game state in Redis hash at key &#96;game:{gameCode}&#96;
+   - [ ] Set TTL on Redis key (3600 seconds)
+   - [ ] Serialize board to BoardDTO format
+   - [ ] Test: Mock Redis client and verify game storage
+   - [ ] Test: Verify TTL is set correctly
+ 
+ - [ ] Task 4: Handle game creation in Gateway (AC: #1)
+   - [ ] Open &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Inject &#96;CreateGameUseCase&#96;
+   - [ ] Add message handler for &#96;{ type: &#39;join&#39;, gameCode: &#39;NEW&#39; }&#96;
+   - [ ] Call &#96;CreateGameUseCase.execute(connectionId)&#96;
+   - [ ] Send &#96;joined&#96; message to client with game code and initial state
+   - [ ] Test: Integration test with WebSocket client
+   - [ ] Test: Verify joined message format matches specification
+ 
+ - [ ] Task 5: Implement message types in shared package (AC: #1)
+   - [ ] Open &#96;packages/shared/src/types/messages.ts&#96;
+   - [ ] Define &#96;JoinGameMessage&#96; type: &#96;{ type: &#39;join&#39;, gameCode: string }&#96;
+   - [ ] Define &#96;JoinedMessage&#96; type with all required fields
+   - [ ] Define &#96;BoardDTO&#96; type: &#96;BoardCell[][]&#96; (from shared types)
+   - [ ] Test: Verify message types compile correctly
+   - [ ] Test: Verify type guards work for message validation
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 2.2 (Status: drafted)**
+ 
+ - **Game Code Generation**: GameCode value object or utility exists for generating unique codes [Source: docs/sprint-artifacts/2-2-game-code-generation.md]
+ - **Uniqueness Check**: Repository interface &#96;IGameRepository&#96; with &#96;exists()&#96; method for uniqueness validation [Source: docs/sprint-artifacts/2-2-game-code-generation.md]
+ - **GameService**: GameService class exists with &#96;createGame()&#96; method structure [Source: docs/sprint-artifacts/2-2-game-code-generation.md]
+ - **Use Existing**: Integrate game code generation with game creation flow
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Use Case Pattern**: Architecture specifies use-cases directory for application use cases [Source: docs/architecture.md#Project-Structure]
+ - **Repository Pattern**: Domain interfaces defined in &#96;domain/interfaces/&#96;, implemented in infrastructure layer [Source: docs/architecture.md#Project-Structure]
+ - **Game State Storage**: Redis stores game state as hash at key &#96;game:{gameCode}&#96; [Source: docs/architecture.md#Integration-Points]
+ - **TTL Configuration**: Game state has TTL (3600 seconds = 1 hour) for automatic cleanup [Source: docs/epics.md#Story-2.3-Game-Creation-with-Initial-State]
+ - **Initial Board State**: Empty 3x3 board format: &#96;[[&quot;&quot;, &quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;, &quot;&quot;]]&#96; [Source: docs/epics.md#Story-2.3-Game-Creation-with-Initial-State]
+ - **Message Protocol**: Joined message includes initial board state per FR20 enhancement [Source: docs/epics.md#Story-2.3-Game-Creation-with-Initial-State]
+ 
+ ### Project Structure Notes
+ 
+ - Game entity: &#96;packages/server/src/domain/entities/Game.ts&#96;
+ - Use case: &#96;packages/server/src/application/use-cases/CreateGameUseCase.ts&#96;
+ - Repository: &#96;packages/server/src/infrastructure/redis/redis-game.repository.ts&#96;
+ - Gateway: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Shared types: &#96;packages/shared/src/types/messages.ts&#96;
+ - Redis key pattern: &#96;game:{gameCode}&#96; for game state storage
+ 
+ ### Testing Standards
+ 
+ - Domain entities: Pure unit tests (100% coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Use cases: Unit tests with mocked repository (90%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Repository: Unit tests with mocked Redis client, integration tests with real Redis (80%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Gateway: Integration tests with test WebSocket clients [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.3-Game-Creation-with-Initial-State]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/architecture.md#Integration-Points]
+ - [Source: docs/prd.md#Functional-Requirements]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---



---


Creating the remaining Epic 2 stories:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-4-game-joining-with-validation.md</summary>

**Chunk 1**
Lines added: 161, lines removed: 1

```diff
@@ -1,1 +1,161 @@
- 
+ # Story 2.4: Game Joining with Validation
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a player,
+ I want to join an existing game using a game code,
+ So that I can play against the game creator.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** a game exists with status &#96;&#39;waiting&#39;&#96; and one player (X)
+    **When** a second client sends &#96;{ type: &#39;join&#39;, gameCode: &#39;ABC123&#39; }&#96; message
+    **Then** the server:
+    - Validates game code exists in Redis
+    - Validates game status is &#96;&#39;waiting&#39;&#96; (not &#96;&#39;playing&#39;&#96; or &#96;&#39;finished&#39;&#96;)
+    - Validates game has space (only one player currently)
+    - Assigns player &#39;O&#39; to the joining client
+    - Updates game state:
+      - Status: &#96;&#39;playing&#39;&#96;
+      - Players: &#96;{ X: &#39;connection-id-1&#39;, O: &#39;connection-id-2&#39; }&#96;
+      - Current player: &#96;&#39;X&#39;&#96; (first player&#39;s turn)
+    - Stores updated game state in Redis
+    - Sends &#96;joined&#96; message to joining client with:
+      - &#96;type: &#39;joined&#39;&#96;
+      - &#96;gameCode: string&#96;
+      - &#96;board: BoardDTO&#96; (current board state)
+      - &#96;currentPlayer: &#39;X&#39;&#96;
+      - &#96;status: &#39;playing&#39;&#96;
+      - &#96;playerSymbol: &#39;O&#39;&#96;
+    - Sends &#96;update&#96; message to first client (X) with:
+      - &#96;type: &#39;update&#39;&#96;
+      - &#96;gameCode: string&#96;
+      - &#96;board: BoardDTO&#96;
+      - &#96;currentPlayer: &#39;X&#39;&#96;
+      - &#96;status: &#39;playing&#39;&#96;
+ 
+ 2. **Given** a game exists with status &#96;&#39;playing&#39;&#96; (two players already)
+    **When** a third client tries to join
+    **Then** the server sends error message:
+    - &#96;type: &#39;error&#39;&#96;
+    - &#96;code: &#39;GAME_FULL&#39;&#96;
+    - &#96;message: &#39;Game already has two players&#39;&#96;
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Implement JoinGameUseCase (AC: #1)
+   - [ ] Create &#96;packages/server/src/application/use-cases/JoinGameUseCase.ts&#96;
+   - [ ] Inject &#96;IGameRepository&#96;
+   - [ ] Implement &#96;execute(gameCode: string, connectionId: string): Promise&lt;JoinedGameResult&gt;&#96;
+   - [ ] Load game from repository by game code
+   - [ ] Validate game exists (throw error if not found)
+   - [ ] Validate game status is &#39;waiting&#39; (throw error if not)
+   - [ ] Validate game has space (only one player) (throw error if full)
+   - [ ] Assign player &#39;O&#39; to connectionId
+   - [ ] Update game status to &#39;playing&#39;
+   - [ ] Update players object with both connection IDs
+   - [ ] Set currentPlayer to &#39;X&#39; (first player&#39;s turn)
+   - [ ] Save updated game to repository
+   - [ ] Return JoinedGameResult with game state and player symbol
+   - [ ] Test: Mock repository and test successful join flow
+   - [ ] Test: Test validation errors (game not found, game full, game already playing)
+ 
+ - [ ] Task 2: Handle join in Gateway (AC: #1, #2)
+   - [ ] Open &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Inject &#96;JoinGameUseCase&#96;
+   - [ ] Add message handler for &#96;{ type: &#39;join&#39;, gameCode: string }&#96; (where gameCode !== &#39;NEW&#39;)
+   - [ ] Call &#96;JoinGameUseCase.execute(gameCode, connectionId)&#96;
+   - [ ] On success: Send &#96;joined&#96; message to joining client
+   - [ ] On success: Send &#96;update&#96; message to first client (X)
+   - [ ] On error: Send &#96;error&#96; message with appropriate error code
+   - [ ] Test: Integration test with two WebSocket clients
+   - [ ] Test: Verify both clients receive correct messages
+   - [ ] Test: Verify error handling for full game
+ 
+ - [ ] Task 3: Implement connection tracking (AC: #1)
+   - [ ] Create &#96;ConnectionManager&#96; service in &#96;packages/server/src/application/services/ConnectionManager.ts&#96;
+   - [ ] Track connection ID to game code mapping
+   - [ ] Track connection ID to player symbol mapping
+   - [ ] Add methods: &#96;registerConnection(connectionId, gameCode, playerSymbol)&#96;, &#96;getGameCode(connectionId)&#96;, &#96;getPlayerSymbol(connectionId)&#96;
+   - [ ] Test: Verify connection tracking works correctly
+   - [ ] Test: Verify can retrieve game code and player symbol by connection ID
+ 
+ - [ ] Task 4: Add error types to shared package (AC: #2)
+   - [ ] Open &#96;packages/shared/src/types/errors.ts&#96;
+   - [ ] Add &#96;ErrorCode&#96; enum with &#96;GAME_FULL&#96;, &#96;GAME_NOT_FOUND&#96;, &#96;GAME_ALREADY_STARTED&#96;
+   - [ ] Update &#96;ErrorMessage&#96; type to use ErrorCode enum
+   - [ ] Test: Verify error types compile correctly
+ 
+ - [ ] Task 5: Update message types (AC: #1)
+   - [ ] Open &#96;packages/shared/src/types/messages.ts&#96;
+   - [ ] Ensure &#96;UpdateMessage&#96; type includes all required fields
+   - [ ] Ensure &#96;ErrorMessage&#96; type includes code field
+   - [ ] Test: Verify message types match specification
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 2.3 (Status: drafted)**
+ 
+ - **Game Entity**: Game entity exists with initial state structure [Source: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md]
+ - **CreateGameUseCase**: CreateGameUseCase implemented for game creation [Source: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md]
+ - **Redis Repository**: RedisGameRepository implements IGameRepository for game storage [Source: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md]
+ - **Message Types**: JoinGameMessage and JoinedMessage types defined in shared package [Source: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md]
+ - **Use Existing**: Reuse Game entity, repository, and message types for join flow
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Use Case Pattern**: Follow same pattern as CreateGameUseCase for JoinGameUseCase [Source: docs/architecture.md#Project-Structure]
+ - **Validation Logic**: Join validation prevents joining started/finished games (FR2 enhancement) [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ - **Player Assignment**: Player assignment tracks which connection is X and which is O [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ - **Message Broadcasting**: Both clients receive appropriate messages (joined vs update) [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ - **Error Handling**: Error handling provides clear feedback for invalid join attempts [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ - **Connection Tracking**: Connection tracking enables message routing to specific clients [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ 
+ ### Project Structure Notes
+ 
+ - Use case: &#96;packages/server/src/application/use-cases/JoinGameUseCase.ts&#96;
+ - Connection manager: &#96;packages/server/src/application/services/ConnectionManager.ts&#96;
+ - Gateway: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Error types: &#96;packages/shared/src/types/errors.ts&#96;
+ - Message types: &#96;packages/shared/src/types/messages.ts&#96;
+ - Connection tracking needed for routing messages to correct clients
+ 
+ ### Testing Standards
+ 
+ - Use cases: Unit tests with mocked repository (90%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Gateway: Integration tests with test WebSocket clients [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Test all validation scenarios (game not found, game full, game already started)
+ - Test message broadcasting to both clients
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.4-Game-Joining-with-Validation]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/prd.md#Functional-Requirements]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-5-websocket-message-protocol-implementation.md</summary>

**Chunk 1**
Lines added: 153, lines removed: 1

```diff
@@ -1,1 +1,153 @@
- 
+ # Story 2.5: WebSocket Message Protocol Implementation
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a developer,
+ I want structured JSON message types for WebSocket communication,
+ So that client and server can exchange game data reliably.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** shared types package exists (Story 1.3)
+    **When** I implement the message protocol
+    **Then** &#96;packages/shared/src/types/messages.ts&#96; defines:
+    - Client → Server messages: &#96;JoinGameMessage&#96;, &#96;MakeMoveMessage&#96;
+    - Server → Client messages: &#96;JoinedMessage&#96;, &#96;UpdateMessage&#96;, &#96;WinMessage&#96;, &#96;DrawMessage&#96;, &#96;ErrorMessage&#96;
+    - Type guards: &#96;isClientMessage()&#96;, &#96;isServerMessage()&#96;
+ 
+ 2. **And** message types match architecture specification:
+    - &#96;JoinGameMessage&#96;: &#96;{ type: &#39;join&#39;, gameCode: string }&#96;
+    - &#96;MakeMoveMessage&#96;: &#96;{ type: &#39;move&#39;, gameCode: string, row: number, col: number }&#96;
+    - &#96;JoinedMessage&#96;: &#96;{ type: &#39;joined&#39;, gameCode: string, board: BoardDTO, currentPlayer: PlayerSymbol, status: GameStatus, playerSymbol: PlayerSymbol }&#96;
+    - &#96;UpdateMessage&#96;: &#96;{ type: &#39;update&#39;, gameCode: string, board: BoardDTO, currentPlayer: PlayerSymbol, status: &#39;playing&#39; }&#96;
+    - &#96;WinMessage&#96;: &#96;{ type: &#39;win&#39;, gameCode: string, board: BoardDTO, winner: PlayerSymbol }&#96;
+    - &#96;DrawMessage&#96;: &#96;{ type: &#39;draw&#39;, gameCode: string, board: BoardDTO }&#96;
+    - &#96;ErrorMessage&#96;: &#96;{ type: &#39;error&#39;, code: ErrorCode, message: string, details?: unknown }&#96;
+ 
+ 3. **And** server Gateway validates incoming messages using type guards
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Define client message types (AC: #1, #2)
+   - [ ] Open &#96;packages/shared/src/types/messages.ts&#96;
+   - [ ] Define &#96;JoinGameMessage&#96; type: &#96;{ type: &#39;join&#39;, gameCode: string }&#96;
+   - [ ] Define &#96;MakeMoveMessage&#96; type: &#96;{ type: &#39;move&#39;, gameCode: string, row: number, col: number }&#96;
+   - [ ] Create union type: &#96;ClientMessage = JoinGameMessage | MakeMoveMessage&#96;
+   - [ ] Test: Verify types compile correctly
+   - [ ] Test: Verify type narrowing works with union type
+ 
+ - [ ] Task 2: Define server message types (AC: #1, #2)
+   - [ ] Continue in &#96;packages/shared/src/types/messages.ts&#96;
+   - [ ] Define &#96;JoinedMessage&#96; type with all required fields
+   - [ ] Define &#96;UpdateMessage&#96; type with all required fields
+   - [ ] Define &#96;WinMessage&#96; type with all required fields
+   - [ ] Define &#96;DrawMessage&#96; type with all required fields
+   - [ ] Define &#96;ErrorMessage&#96; type with code, message, and optional details
+   - [ ] Create union type: &#96;ServerMessage = JoinedMessage | UpdateMessage | WinMessage | DrawMessage | ErrorMessage&#96;
+   - [ ] Test: Verify all message types compile correctly
+   - [ ] Test: Verify type narrowing works with union type
+ 
+ - [ ] Task 3: Import required types (AC: #2)
+   - [ ] Import &#96;BoardDTO&#96; from &#96;./game.ts&#96; (or define if needed)
+   - [ ] Import &#96;PlayerSymbol&#96; from &#96;./game.ts&#96;
+   - [ ] Import &#96;GameStatus&#96; from &#96;./game.ts&#96;
+   - [ ] Import &#96;ErrorCode&#96; from &#96;./errors.ts&#96;
+   - [ ] Test: Verify all imports resolve correctly
+ 
+ - [ ] Task 4: Implement type guards (AC: #1)
+   - [ ] Implement &#96;isClientMessage(message: unknown): message is ClientMessage&#96;
+   - [ ] Check message has &#96;type&#96; field
+   - [ ] Check type is &#39;join&#39; or &#39;move&#39;
+   - [ ] Validate required fields based on type
+   - [ ] Implement &#96;isServerMessage(message: unknown): message is ServerMessage&#96;
+   - [ ] Check message has &#96;type&#96; field
+   - [ ] Check type is &#39;joined&#39;, &#39;update&#39;, &#39;win&#39;, &#39;draw&#39;, or &#39;error&#39;
+   - [ ] Validate required fields based on type
+   - [ ] Test: Verify type guards correctly identify valid messages
+   - [ ] Test: Verify type guards reject invalid messages
+   - [ ] Test: Verify type guards work with runtime validation
+ 
+ - [ ] Task 5: Export types and guards (AC: #1)
+   - [ ] Export all message types from &#96;messages.ts&#96;
+   - [ ] Export type guards from &#96;messages.ts&#96;
+   - [ ] Update &#96;packages/shared/src/index.ts&#96; to export message types
+   - [ ] Test: Verify types can be imported by server and client packages
+ 
+ - [ ] Task 6: Use type guards in Gateway (AC: #3)
+   - [ ] Open &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Import &#96;isClientMessage&#96; from shared types
+   - [ ] Add message validation in message handler
+   - [ ] Validate incoming messages using &#96;isClientMessage()&#96;
+   - [ ] Send error message if validation fails
+   - [ ] Test: Verify Gateway validates messages correctly
+   - [ ] Test: Verify invalid messages are rejected
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 1.3 (Status: drafted)**
+ 
+ - **Shared Types Package**: Shared types package exists with basic structure [Source: docs/sprint-artifacts/1-3-shared-types-package-setup.md]
+ - **Type Definitions**: Types directory structure exists: &#96;messages.ts&#96;, &#96;game.ts&#96;, &#96;errors.ts&#96; [Source: docs/sprint-artifacts/1-3-shared-types-package-setup.md]
+ - **Use Existing**: Build on existing shared types structure, may need to enhance types defined in Story 1.3
+ 
+ **From Story 2.3 (Status: drafted)**
+ 
+ - **Message Types Started**: JoinGameMessage and JoinedMessage types may have been started in Story 2.3 [Source: docs/sprint-artifacts/2-3-game-creation-with-initial-state.md]
+ - **Use Existing**: Enhance and complete message types, ensure consistency
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Shared Types**: Shared types ensure protocol consistency between client and server [Source: docs/epics.md#Story-2.5-WebSocket-Message-Protocol-Implementation]
+ - **Type Guards**: Type guards enable runtime validation of messages [Source: docs/epics.md#Story-2.5-WebSocket-Message-Protocol-Implementation]
+ - **BoardDTO Format**: BoardDTO (BoardCell[][]) used for JSON serialization [Source: docs/epics.md#Story-2.5-WebSocket-Message-Protocol-Implementation]
+ - **Error Codes**: Error codes defined in shared types for consistent error handling [Source: docs/epics.md#Story-2.5-WebSocket-Message-Protocol-Implementation]
+ - **Message Protocol**: JSON-based message format for all communications [Source: docs/prd.md#WebSocket-Message-Protocol]
+ 
+ ### Project Structure Notes
+ 
+ - Message types: &#96;packages/shared/src/types/messages.ts&#96;
+ - Game types: &#96;packages/shared/src/types/game.ts&#96; (for BoardDTO, PlayerSymbol, GameStatus)
+ - Error types: &#96;packages/shared/src/types/errors.ts&#96; (for ErrorCode)
+ - Export: &#96;packages/shared/src/index.ts&#96;
+ - Gateway: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Types must be importable by both server and client packages
+ 
+ ### Testing Standards
+ 
+ - Shared types: Pure unit tests for type guards (100% coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Test type guards with valid and invalid messages
+ - Test type narrowing with TypeScript compiler
+ - Test runtime validation scenarios
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.5-WebSocket-Message-Protocol-Implementation]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/prd.md#WebSocket-Message-Protocol]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---



---


Creating the final two Epic 2 stories:


---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-6-message-validation-and-error-handling.md</summary>

**Chunk 1**
Lines added: 152, lines removed: 1

```diff
@@ -1,1 +1,152 @@
- 
+ # Story 2.6: Message Validation and Error Handling
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a player,
+ I want clear error messages when my requests are invalid,
+ So that I understand what went wrong and how to fix it.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** a client sends an invalid message
+    **When** the server receives it
+    **Then** the server validates:
+    - Message is valid JSON
+    - Message has required &#96;type&#96; field
+    - Message type is recognized (&#96;&#39;join&#39;&#96; or &#96;&#39;move&#39;&#96;)
+    - Required fields are present (e.g., &#96;gameCode&#96; for join/move, &#96;row&#96;/&#96;col&#96; for move)
+ 
+ 2. **And** if validation fails, server sends error message:
+    - &#96;type: &#39;error&#39;&#96;
+    - &#96;code: &#39;INVALID_MESSAGE&#39;&#96;
+    - &#96;message: string&#96; describing the issue (e.g., &quot;Missing required field: gameCode&quot;)
+ 
+ 3. **Given** a client sends &#96;{ type: &#39;join&#39;, gameCode: &#39;INVALID&#39; }&#96; for non-existent game
+    **When** the server processes it
+    **Then** server sends error:
+    - &#96;type: &#39;error&#39;&#96;
+    - &#96;code: &#39;GAME_NOT_FOUND&#39;&#96;
+    - &#96;message: &quot;Game code &#39;INVALID&#39; does not exist&quot;&#96;
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Create MessageValidator service (AC: #1, #2)
+   - [ ] Create &#96;packages/server/src/application/services/MessageValidator.ts&#96;
+   - [ ] Implement &#96;validateMessage(message: unknown): ValidationResult&#96;
+   - [ ] Check message is valid JSON (parse if string)
+   - [ ] Check message has &#96;type&#96; field
+   - [ ] Check message type is recognized (&#39;join&#39; or &#39;move&#39;)
+   - [ ] Validate required fields based on message type:
+      - JoinGameMessage: requires &#96;gameCode&#96; field
+      - MakeMoveMessage: requires &#96;gameCode&#96;, &#96;row&#96;, &#96;col&#96; fields
+   - [ ] Return ValidationResult with success/error details
+   - [ ] Test: Test JSON parsing errors
+   - [ ] Test: Test missing type field
+   - [ ] Test: Test unrecognized message type
+   - [ ] Test: Test missing required fields for each message type
+ 
+ - [ ] Task 2: Create ErrorResponse builder (AC: #2, #3)
+   - [ ] Create &#96;ErrorResponseBuilder&#96; utility in &#96;packages/server/src/application/utils/ErrorResponseBuilder.ts&#96;
+   - [ ] Implement &#96;buildErrorResponse(code: ErrorCode, message: string, details?: unknown): ErrorMessage&#96;
+   - [ ] Map common validation errors to ErrorCode enum
+   - [ ] Format user-friendly error messages
+   - [ ] Test: Verify error response format matches ErrorMessage type
+   - [ ] Test: Verify error codes are correct
+ 
+ - [ ] Task 3: Integrate validation in Gateway (AC: #1, #2)
+   - [ ] Open &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Inject &#96;MessageValidator&#96;
+   - [ ] Add validation middleware/handler before message processing
+   - [ ] Validate incoming messages using &#96;MessageValidator.validateMessage()&#96;
+   - [ ] If validation fails, send error message using &#96;ErrorResponseBuilder&#96;
+   - [ ] Test: Integration test with invalid messages
+   - [ ] Test: Verify error messages are sent correctly
+ 
+ - [ ] Task 4: Handle game not found error (AC: #3)
+   - [ ] Update &#96;JoinGameUseCase&#96; to throw &#96;GameNotFoundException&#96; when game not found
+   - [ ] Create &#96;GameNotFoundException&#96; custom exception class
+   - [ ] Map exception to ErrorCode &#96;GAME_NOT_FOUND&#96;
+   - [ ] Update Gateway to catch exception and send error message
+   - [ ] Test: Test game not found scenario
+   - [ ] Test: Verify error message format
+ 
+ - [ ] Task 5: Add error codes to shared package (AC: #2, #3)
+   - [ ] Open &#96;packages/shared/src/types/errors.ts&#96;
+   - [ ] Ensure &#96;ErrorCode&#96; enum includes: &#96;INVALID_MESSAGE&#96;, &#96;GAME_NOT_FOUND&#96;, &#96;GAME_FULL&#96;
+   - [ ] Update &#96;ErrorMessage&#96; type if needed
+   - [ ] Test: Verify error codes compile correctly
+ 
+ - [ ] Task 6: Add error handling to message handlers (AC: #2, #3)
+   - [ ] Wrap all message handlers in Gateway with try-catch
+   - [ ] Catch validation errors and send INVALID_MESSAGE error
+   - [ ] Catch business logic errors (game not found, etc.) and send appropriate error
+   - [ ] Log errors for debugging
+   - [ ] Test: Test error handling for all error scenarios
+   - [ ] Test: Verify errors don&#39;t crash server
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 2.5 (Status: drafted)**
+ 
+ - **Message Types**: All message types defined in shared package [Source: docs/sprint-artifacts/2-5-websocket-message-protocol-implementation.md]
+ - **Type Guards**: &#96;isClientMessage()&#96; and &#96;isServerMessage()&#96; type guards implemented [Source: docs/sprint-artifacts/2-5-websocket-message-protocol-implementation.md]
+ - **Error Types**: ErrorCode enum and ErrorMessage type defined [Source: docs/sprint-artifacts/2-5-websocket-message-protocol-implementation.md]
+ - **Use Existing**: Build on type guards, enhance with detailed validation and error handling
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Message Validation**: Message validation prevents malformed requests from causing errors [Source: docs/epics.md#Story-2.6-Message-Validation-and-Error-Handling]
+ - **Clear Error Codes**: Clear error codes enable client-side error handling [Source: docs/epics.md#Story-2.6-Message-Validation-and-Error-Handling]
+ - **User-Friendly Messages**: Error messages should be user-friendly but include details for debugging [Source: docs/epics.md#Story-2.6-Message-Validation-and-Error-Handling]
+ - **Validation Order**: Validation happens before business logic processing [Source: docs/epics.md#Story-2.6-Message-Validation-and-Error-Handling]
+ - **Error Handling**: System validates incoming message structure and required fields (FR28) [Source: docs/prd.md#Functional-Requirements]
+ - **Error Messages**: System sends appropriate error messages for invalid requests (FR29) [Source: docs/prd.md#Functional-Requirements]
+ 
+ ### Project Structure Notes
+ 
+ - Validator service: &#96;packages/server/src/application/services/MessageValidator.ts&#96;
+ - Error builder: &#96;packages/server/src/application/utils/ErrorResponseBuilder.ts&#96;
+ - Custom exceptions: &#96;packages/server/src/domain/exceptions/&#96; (or similar)
+ - Gateway: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Error types: &#96;packages/shared/src/types/errors.ts&#96;
+ - Validation should happen early in request pipeline
+ 
+ ### Testing Standards
+ 
+ - Validator service: Unit tests with various invalid message scenarios (90%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Gateway: Integration tests with invalid messages [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Test all validation scenarios (JSON parsing, missing fields, invalid types)
+ - Test error message format and codes
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.6-Message-Validation-and-Error-Handling]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/prd.md#Functional-Requirements]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="write">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-artifacts/2-7-connection-management-and-cleanup.md</summary>

**Chunk 1**
Lines added: 150, lines removed: 1

```diff
@@ -1,1 +1,150 @@
- 
+ # Story 2.7: Connection Management and Cleanup
+ 
+ Status: drafted
+ 
+ ## Story
+ 
+ As a developer,
+ I want proper WebSocket connection lifecycle management,
+ So that disconnected clients don&#39;t leave orphaned game state.
+ 
+ ## Acceptance Criteria
+ 
+ 1. **Given** a client is connected and joined to a game
+    **When** the client disconnects (WebSocket close event)
+    **Then** the server:
+    - Detects disconnection in &#96;handleDisconnect()&#96; method
+    - Removes connection from game&#39;s player tracking (if applicable)
+    - Updates game state if needed (e.g., mark player as disconnected)
+    - Logs disconnection event for debugging
+ 
+ 2. **And** if both players disconnect:
+    - Game state remains in Redis (with TTL)
+    - Game can be rejoined if players reconnect (optional for MVP)
+ 
+ 3. **And** connection tracking maps WebSocket connections to:
+    - Game codes they&#39;re participating in
+    - Player symbols (X or O) assigned to them
+ 
+ ## Tasks / Subtasks
+ 
+ - [ ] Task 1: Enhance ConnectionManager service (AC: #3)
+   - [ ] Open &#96;packages/server/src/application/services/ConnectionManager.ts&#96; (created in Story 2.4)
+   - [ ] Add method: &#96;removeConnection(connectionId: string): void&#96;
+   - [ ] Add method: &#96;getConnectionsByGameCode(gameCode: string): string[]&#96; (returns connection IDs)
+   - [ ] Add method: &#96;removeConnectionFromGame(connectionId: string, gameCode: string): void&#96;
+   - [ ] Maintain bidirectional mapping: connectionId → gameCode, gameCode → connectionIds[]
+   - [ ] Test: Verify connection removal works correctly
+   - [ ] Test: Verify can retrieve connections by game code
+ 
+ - [ ] Task 2: Implement disconnection handler in Gateway (AC: #1)
+   - [ ] Open &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+   - [ ] Enhance &#96;handleDisconnect()&#96; method (already exists from Story 2.1)
+   - [ ] Inject &#96;ConnectionManager&#96;
+   - [ ] Get game code for disconnected connection
+   - [ ] Remove connection from ConnectionManager
+   - [ ] If game exists, update game state (mark player as disconnected)
+   - [ ] Log disconnection event with connection ID and game code
+   - [ ] Test: Integration test with WebSocket client disconnection
+   - [ ] Test: Verify connection is removed from tracking
+ 
+ - [ ] Task 3: Update game state on disconnection (AC: #1)
+   - [ ] Create &#96;UpdateGameOnDisconnectionUseCase&#96; in &#96;packages/server/src/application/use-cases/UpdateGameOnDisconnectionUseCase.ts&#96;
+   - [ ] Inject &#96;IGameRepository&#96; and &#96;ConnectionManager&#96;
+   - [ ] Implement &#96;execute(connectionId: string): Promise&lt;void&gt;&#96;
+   - [ ] Get game code from ConnectionManager
+   - [ ] Load game from repository
+   - [ ] Remove connection ID from players object (set to undefined)
+   - [ ] Update game state in repository
+   - [ ] Test: Mock repository and verify game state update
+   - [ ] Test: Verify player is removed from players object
+ 
+ - [ ] Task 4: Handle both players disconnected (AC: #2)
+   - [ ] Update &#96;UpdateGameOnDisconnectionUseCase&#96;
+   - [ ] Check if both players are disconnected (both undefined in players object)
+   - [ ] If both disconnected, game state remains in Redis (TTL handles cleanup)
+   - [ ] Optionally: Mark game status as &#39;abandoned&#39; (optional for MVP)
+   - [ ] Test: Test scenario where both players disconnect
+   - [ ] Test: Verify game state remains in Redis
+ 
+ - [ ] Task 5: Add reconnection support (optional for MVP) (AC: #2)
+   - [ ] If reconnection supported: Allow player to rejoin game using same game code
+   - [ ] Validate player can rejoin if game status allows
+   - [ ] Restore player assignment (X or O) based on game state
+   - [ ] Test: Test reconnection scenario (if implemented)
+ 
+ - [ ] Task 6: Enhance logging (AC: #1)
+   - [ ] Add structured logging for connection events
+   - [ ] Log connection ID, game code, player symbol on disconnect
+   - [ ] Log game state after disconnection
+   - [ ] Use appropriate log levels (info for normal, warn for errors)
+   - [ ] Test: Verify logs are generated correctly
+ 
+ ## Dev Notes
+ 
+ ### Learnings from Previous Story
+ 
+ **From Story 2.1 (Status: drafted)**
+ 
+ - **Disconnect Handler**: &#96;handleDisconnect()&#96; method exists in GameGateway [Source: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md]
+ - **Connection Lifecycle**: Gateway handles connection lifecycle via &#96;OnGatewayDisconnect&#96; interface [Source: docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md]
+ - **Use Existing**: Enhance existing disconnect handler with cleanup logic
+ 
+ **From Story 2.4 (Status: drafted)**
+ 
+ - **ConnectionManager**: ConnectionManager service exists for tracking connections [Source: docs/sprint-artifacts/2-4-game-joining-with-validation.md]
+ - **Connection Tracking**: Connection tracking maps connections to game codes and player symbols [Source: docs/sprint-artifacts/2-4-game-joining-with-validation.md]
+ - **Use Existing**: Enhance ConnectionManager with disconnection cleanup methods
+ 
+ ### Architecture Patterns and Constraints
+ 
+ - **Connection Cleanup**: Connection cleanup prevents memory leaks [Source: docs/epics.md#Story-2.7-Connection-Management-and-Cleanup]
+ - **Disconnection Handling**: Disconnection handling needed for graceful degradation [Source: docs/epics.md#Story-2.7-Connection-Management-and-Cleanup]
+ - **Connection Tracking**: Connection tracking enables message routing to specific clients [Source: docs/epics.md#Story-2.7-Connection-Management-and-Cleanup]
+ - **Redis TTL**: Redis TTL handles abandoned games automatically [Source: docs/epics.md#Story-2.7-Connection-Management-and-Cleanup]
+ - **Error Handling**: System provides error handling framework for connection failures (FR30) [Source: docs/prd.md#Functional-Requirements]
+ 
+ ### Project Structure Notes
+ 
+ - Connection manager: &#96;packages/server/src/application/services/ConnectionManager.ts&#96;
+ - Use case: &#96;packages/server/src/application/use-cases/UpdateGameOnDisconnectionUseCase.ts&#96;
+ - Gateway: &#96;packages/server/src/presentation/game/game.gateway.ts&#96;
+ - Repository: &#96;packages/server/src/infrastructure/redis/redis-game.repository.ts&#96;
+ - Connection cleanup should happen synchronously on disconnect
+ 
+ ### Testing Standards
+ 
+ - Connection manager: Unit tests for connection tracking and removal (90%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Use case: Unit tests with mocked repository (90%+ coverage) [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Gateway: Integration tests with WebSocket client disconnection [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ - Test single player disconnect, both players disconnect scenarios
+ - Test connection cleanup and game state updates
+ - TDD approach: Write tests first, then implement
+ 
+ ### References
+ 
+ - [Source: docs/epics.md#Story-2.7-Connection-Management-and-Cleanup]
+ - [Source: docs/architecture.md#Project-Structure]
+ - [Source: docs/prd.md#Functional-Requirements]
+ - [Source: docs/sprint-planning.md#Testing-Strategy-by-Layer]
+ 
+ ## Dev Agent Record
+ 
+ ### Context Reference
+ 
+ &lt;!-- Path(s) to story context XML will be added here by context workflow --&gt;
+ 
+ ### Agent Model Used
+ 
+ {{agent_model_name_version}}
+ 
+ ### Debug Log References
+ 
+ ### Completion Notes List
+ 
+ ### File List
+ 
+ ## Change Log
+ 
+ - 2025-11-20: Story created from Epic 2 breakdown
+ 
```

</details>

</tool-use>

---



---


Updating sprint-status.yaml to mark all Epic 2 stories as "drafted":


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **code_edit** • Edit file: docs/sprint-status.yaml</summary>

**Chunk 1**
Lines added: 7, lines removed: 7

```diff
@@ -33,11 +33,11 @@
    epic-1-retrospective: optional
    epic-2: backlog
-   2-1-websocket-server-setup-with-nestjs-gateway: backlog
-   2-2-game-code-generation: backlog
-   2-3-game-creation-with-initial-state: backlog
-   2-4-game-joining-with-validation: backlog
-   2-5-websocket-message-protocol-implementation: backlog
-   2-6-message-validation-and-error-handling: backlog
-   2-7-connection-management-and-cleanup: backlog
+   2-1-websocket-server-setup-with-nestjs-gateway: drafted
+   2-2-game-code-generation: drafted
+   2-3-game-creation-with-initial-state: drafted
+   2-4-game-joining-with-validation: drafted
+   2-5-websocket-message-protocol-implementation: drafted
+   2-6-message-validation-and-error-handling: drafted
+   2-7-connection-management-and-cleanup: drafted
    epic-2-retrospective: optional
  
```

</details>

</tool-use>

---



---


Created all 7 Epic 2 stories. Summary:

## Stories created

1. **2-1-websocket-server-setup-with-nestjs-gateway.md** — WebSocket Gateway setup with NestJS
2. **2-2-game-code-generation.md** — Unique game code generation system
3. **2-3-game-creation-with-initial-state.md** — Game creation with initial state and Redis storage
4. **2-4-game-joining-with-validation.md** — Game joining with validation and player assignment
5. **2-5-websocket-message-protocol-implementation.md** — WebSocket message protocol types and guards
6. **2-6-message-validation-and-error-handling.md** — Message validation and error handling
7. **2-7-connection-management-and-cleanup.md** — Connection lifecycle management and cleanup

## Story details

Each story includes:
- Story statement (As a/I want/So that)
- Acceptance criteria from epics.md
- Tasks/subtasks mapped to ACs
- Dev notes with:
  - Learnings from previous stories
  - Architecture patterns and constraints
  - Project structure notes
  - Testing standards
  - References to source documents
- Dev Agent Record sections (ready for implementation)

## Status update

All Epic 2 stories are marked as "drafted" in `sprint-status.yaml`.

## Next steps

1. Review the story files in `docs/sprint-artifacts/`
2. Run `*story-context` to generate technical context XML and mark stories ready for development
3. Or run `*story-ready` to mark stories ready without generating context

All stories follow the template structure and reference the architecture, PRD, and epics documents. Ready for development.

---

_**User (2025-11-20 13:18Z)**_

commit all of those file as conventional commit

---

_**Agent (model composer-1, mode Agent)**_



---


Committing all Epic 2 story files and the sprint-status.yaml update using conventional commit format.


---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/ofeki/repos/fusion-tic-tac-toe && git add docs/sprint-artifacts/2-*.md docs/sprint-status.yaml</summary>

```bash
cd /Users/ofeki/repos/fusion-tic-tac-toe && git add docs/sprint-artifacts/2-*.md docs/sprint-status.yaml
```
</details>
</tool-use>

---



---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/ofeki/repos/fusion-tic-tac-toe && git commit -m "docs(stories): create Epic 2 game session management stories

- Add 7 story files for Epic 2: WebSocket setup, game code generation, game creation, game joining, message protocol, validation, and connection management
- Update sprint-status.yaml to mark all Epic 2 stories as drafted
- Each story includes acceptance criteria, tasks, dev notes, and references to architecture/PRD/epics"</summary>

```bash
cd /Users/ofeki/repos/fusion-tic-tac-toe && git commit -m "docs(stories): create Epic 2 game session management stories

- Add 7 story files for Epic 2: WebSocket setup, game code generation, game creation, game joining, message protocol, validation, and connection management
- Update sprint-status.yaml to mark all Epic 2 stories as drafted
- Each story includes acceptance criteria, tasks, dev notes, and references to architecture/PRD/epics"
```

```
[main c953c9b] docs(stories): create Epic 2 game session management stories
 8 files changed, 1012 insertions(+), 7 deletions(-)
 create mode 100644 docs/sprint-artifacts/2-1-websocket-server-setup-with-nestjs-gateway.md
 create mode 100644 docs/sprint-artifacts/2-2-game-code-generation.md
 create mode 100644 docs/sprint-artifacts/2-3-game-creation-with-initial-state.md
 create mode 100644 docs/sprint-artifacts/2-4-game-joining-with-validation.md
 create mode 100644 docs/sprint-artifacts/2-5-websocket-message-protocol-implementation.md
 create mode 100644 docs/sprint-artifacts/2-6-message-validation-and-error-handling.md
 create mode 100644 docs/sprint-artifacts/2-7-connection-management-and-cleanup.md

```
</details>
</tool-use>

---





---



---


Committed all files using conventional commit format.

**Commit details:**
- **Type:** `docs` (documentation changes)
- **Scope:** `stories`
- **Files committed:** 8 files
  - 7 new Epic 2 story files
  - 1 updated sprint-status.yaml
- **Changes:** 1,012 insertions, 7 deletions

**Commit message:**
```
docs(stories): create Epic 2 game session management stories

- Add 7 story files for Epic 2: WebSocket setup, game code generation, 
  game creation, game joining, message protocol, validation, and 
  connection management
- Update sprint-status.yaml to mark all Epic 2 stories as drafted
- Each story includes acceptance criteria, tasks, dev notes, and 
  references to architecture/PRD/epics
```

All Epic 2 stories are committed and ready for the next workflow step.

---

